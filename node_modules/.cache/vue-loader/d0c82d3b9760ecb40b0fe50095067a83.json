{"remainingRequest":"/home/runner/work/U3_Pensamiento_Algoritmico/U3_Pensamiento_Algoritmico/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/runner/work/U3_Pensamiento_Algoritmico/U3_Pensamiento_Algoritmico/src/views/curso/Tema1.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/runner/work/U3_Pensamiento_Algoritmico/U3_Pensamiento_Algoritmico/src/views/curso/Tema1.vue","mtime":1736118184541},{"path":"/home/runner/work/U3_Pensamiento_Algoritmico/U3_Pensamiento_Algoritmico/node_modules/babel-loader/lib/index.js","mtime":456789000000},{"path":"/home/runner/work/U3_Pensamiento_Algoritmico/U3_Pensamiento_Algoritmico/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/runner/work/U3_Pensamiento_Algoritmico/U3_Pensamiento_Algoritmico/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnVGVtYTEnLAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBpdGVtczogWwogICAgICAgIHsKICAgICAgICAgIHRleHQ6ICdTaWVtcHJlIGRlYmUgdGVuZXIgdW4gaW5pY2lvLicsCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICB0ZXh0OgogICAgICAgICAgICAnRGViZXLDoSBzZXIgcHJlY2lzbywgY29udGVtcGxhciBlbCBvcmRlbiBlc3RydWN0dXJhbCB5IHNlY3VlbmNpYWwgZGVsIHByb2Nlc28geSBlc3RhYmxlY2VyIHByaW9yaWRhZGVzLicsCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICB0ZXh0OgogICAgICAgICAgICAnRGViZSBlc3RhciBkZWZpbmlkbywgbG8gcXVlIGEgc3UgdmV6IHRyYWR1Y2UgZW4gcXVlIGNhZGEgdmV6IHF1ZSBzZSBlamVjdXRlIGVsIGFsZ29yaXRtbywgc2Ugb2J0aWVuZW4gbG9zIG1pc21vcyByZXN1bHRhZG9zLicsCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICB0ZXh0OgogICAgICAgICAgICAnU2llbXByZSBkZWJlIHRlbmVyIHVuIGZpbiwgZGViZXLDoSB0ZXJtaW5hciBlbCBhbGfDum4gbW9tZW50bzsgZXMgZGVjaXIsIHVuIG7Dum1lcm8gZGUgcGFzb3MgZXN0YWJsZWNpZG8uJywKICAgICAgICB9LAogICAgICBdLAogICAgfQogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgdGhpcy4kYW9zUmVmcmVzaCgpCiAgICB9KQogIH0sCn0K"},{"version":3,"sources":["Tema1.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Tema1.vue","sourceRoot":"src/views/curso","sourcesContent":["<template lang=\"pug\">\n.curso-main-container.pb-3\n  BannerInterno(:titulo=\"'Unidad 3. Diseño e implementación de algoritmos'\" :subTitulo=\"'1. Conceptos generales en el diseño de algoritmos eficientes'\")\n  .container.tarjeta.tarjeta--blanca.px-4.px-md-5.pt-4.pt-md-5.pb-0.overflow-hidden\n\n    .row.mb-4\n      .col-12.col-xl-7(data-aos=\"fade-right\")\n        p.mb-4 Antes de comenzar con el desarrollo de este tema, es importante que repase los conceptos generales de algoritmos, así podrá comprender con mayor grado de precisión cada uno de los ejemplos aquí utilizados, además de proponer soluciones de mejora para cada caso. \n        .d-flex.align-items-start.bg-azul-claro.p-4.mb-4(data-aos=\"fade-left\")\n          img.me-3(style=\"width: 90px\" src='@/assets/curso/unidad/img-4.svg', alt='Texto que describa la imagen')\n          .d-flex.flex-column\n            p.pe-xl-3.mb-0(data-aos=\"fade-up\") En la construcción de algoritmos se pueden encontrar diferentes enfoques que permiten dar solución a los problemas computacionales. Los paradigmas en el diseño de algoritmos son como un maletín repleto de herramientas, cada una con una finalidad específica, así; podrá utilizar según las fortalezas y el caso propuesto alguna de ellas. Como señala Mancilla Herrera (2015), \"el dominio de diferentes paradigmas de diseño te permitirá abordar problemas complejos de manera sistemática y eficiente\" (p. 67).\n        p.mb-0 A continuación se darán a conocer los grandes rasgos en los fundamentos del diseño de algoritmos. \n      .col-12.col-xl-5.d-none.d-xl-block(data-aos=\"fade-left\")\n        img(src='@/assets/curso/unidad/img-5.png', alt='Texto que describa la imagen')\n\n    #t_1_1.titulo-segundo\n      div.d-flex\n        span.me-3 1.1  \n        h2 Fundamentos del diseño algorítmico\n\n    p.mb-4 Los principios que rigen el diseño de un algoritmo son:\n\n    TabsC.mb-5\n      .tabs-content.border.px-4.p-md-5.py-3(titulo=\"Corrección\", :iconUrl=\"require('@/assets/curso/unidad/img-6.svg')\")\n        .row\n          .d-none.d-lg-block.col-md-12.col-lg-5.col-xl-4(data-aos=\"fade-right\")\n            figure\n              img(src='@/assets/curso/unidad/img-11.png', alt='Texto que describa la imagen')\n          .col-md-12.col-lg-7.col-xl-8.mb-4.mb-md-0(data-aos=\"fade-left\")\n            h4 Corrección\n            p(data-aos=\"fade-up\") Para todas las entradas  de datos válidos se deberá producir la salida correcta. \n      .tabs-content.border.px-4.p-md-5.py-3(titulo=\"Eficiencia\", :iconUrl=\"require('@/assets/curso/unidad/img-7.svg')\")\n        .row\n          .d-none.d-lg-block.col-md-12.col-lg-5.col-xl-4(data-aos=\"fade-right\")\n            figure\n              img(src='@/assets/curso/unidad/img-12.png', alt='Texto que describa la imagen')\n          .col-md-12.col-lg-7.col-xl-8.mb-4.mb-md-0(data-aos=\"fade-left\")\n            h4 Eficiencia\n            p(data-aos=\"fade-up\") Los recursos como tiempo de ejecución y memoria utilizada deberán utilizarse de la manera más óptima.\n      .tabs-content.border.px-4.p-md-5.py-3(titulo=\"Simplicidad\", :iconUrl=\"require('@/assets/curso/unidad/img-8.svg')\")\n        .row\n          .d-none.d-lg-block.col-md-12.col-lg-5.col-xl-4(data-aos=\"fade-right\")\n            figure\n              img(src='@/assets/curso/unidad/img-13.png', alt='Texto que describa la imagen')\n          .col-md-12.col-lg-7.col-xl-8.mb-4.mb-md-0(data-aos=\"fade-left\")\n            h4 Simplicidad\n            p(data-aos=\"fade-up\") El código debe ser claro y preciso.\n      .tabs-content.border.px-4.p-md-5.py-3(titulo=\"Modularidad\", :iconUrl=\"require('@/assets/curso/unidad/img-9.svg')\")\n        .row\n          .d-none.d-lg-block.col-md-12.col-lg-5.col-xl-4(data-aos=\"fade-right\")\n            figure\n              img(src='@/assets/curso/unidad/img-14.png', alt='Texto que describa la imagen')\n          .col-md-12.col-lg-7.col-xl-8.mb-4.mb-md-0(data-aos=\"fade-left\")\n            h4 Modularidad\n            p(data-aos=\"fade-up\") Se debe dividir el problema en segmentos manejables.\n      .tabs-content.border.px-4.p-md-5.py-3(titulo=\"Escalabilidad\", :iconUrl=\"require('@/assets/curso/unidad/img-10.svg')\")\n        .row\n          .d-none.d-lg-block.col-md-12.col-lg-5.col-xl-4(data-aos=\"fade-right\")\n            figure\n              img(src='@/assets/curso/unidad/img-15.png', alt='Texto que describa la imagen')\n          .col-md-12.col-lg-7.col-xl-8.mb-4.mb-md-0(data-aos=\"fade-left\")\n            h4 Escalabilidad\n            p(data-aos=\"fade-up\") Incluso al incrementar los datos de entrada el código deberá funcionar eficientemente.\n\n    p.mb-4 Algunos de los paradigmas más importantes utilizados a la hora de producir algoritmos son: \n    p.mb-3 <strong>Tabla 1</strong> Paradigmas más utilizados al producir algoritmos\n\n    .tabla-a.mb-4\n      table.text-center\n        thead\n          tr\n            th.text-center(width=\"20%\") Paradigma\n            th.text-center Características\n            th.text-center Aplicaciones prácticas\n        tbody\n          tr\n            td.text-bold.bg-gris.h-100.align-baseline.text-start.border-right-gris Divide y vencerás\n            td.text-start.pb-0.border-right-gris\n              p.mb-3 Los pasos que sigue este paradigma son:\n              p.mb-1.ms-3 1. Dividir\n              p.mb-1.ms-3 2. Conquistar\n              p.mb-3.ms-3 3. Combinar\n            td.bg-gris.align-baseline.text-start\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Ordenamiento (MergeSort, QuickSort).\n \n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Multiplicación de matrices de Strassen.\n\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Transformada rápida de Fourier (FFT).\n          tr\n            td.text-bold.align-baseline.text-start.border-right-gris Divide and <i>Conquer</i>\n            td.text-start.pt-0.bg-white.border-bottom-gris.border-right-gris\n              p.mb-3 En el paso 1, se descompone el problema en subproblemas; posteriormente, en el paso 2 se resuelven cada uno de esos “subproblemas, usando recursividad”; para finalizar, se utiliza combinar, para unir las soluciones a los subproblemas.\n            td.bg-gris.border-bottom-gris\n\n          tr\n            td.bg-gris.border-bottom-gris.border-right-gris\n            td.bg-white.text-start.border-bottom-gris(colspan=\"2\") Este paradigma permite abordar problemas complejos dividiéndolos en subproblemas más pequeños y manejables. Como señala Mancilla Herrera (2015), \"la estrategia divide y vencerás, es fundamental en el diseño de algoritmos eficientes, permitiendo reducir la complejidad de problemas aparentemente intratables\" (p. 45).\n\n          tr\n            td.bg-gris.text-bold.align-baseline.text-start.border-right-gris Programación dinámica\n            td.bg-white.border-bottom-gris.align-baseline.text-start.border-right-gris\n              p.mb-3 Se utiliza cuando:\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Los problemas se superponen.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Los problemas tienen una subestructura óptima.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0.pe-xl-5 Las soluciones de los subproblemas se pueden almacenar.\n            td.bg-gris.border-bottom-gris.align-baseline.text-start\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Memorización de resultados.  \n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Eliminación de cálculos redundantes.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Optimización de subproblemas.\n\n          tr\n            td.bg-gris.border-bottom-gris.border-right-gris\n            td.bg-gris.text-start.border-bottom-gris(colspan=\"2\") Cuando se enfrenta a problemas con subproblemas superpuestos, la programación dinámica es la mejor aliada. Esta técnica almacena resultados intermedios, para evitar cálculos redundantes, mejorando significativamente la eficiencia.\n\n          tr\n            td.bg-white.align-baseline.text-start.text-bold.border-right-gris Algoritmos voraces\n            td.text-start.pb-0.border-right-gris.bg-white\n              p.mb-3 Principios de diseño:\n              p.mb-1.ms-3.pe-xxl-5 <strong>1. Selección voraz:</strong> elegir la mejor opción disponible. \n              p.mb-1.ms-3.pe-xxl-5 <strong>2. Factibilidad:</strong> verificar si la elección mantiene una solución viable.\n              p.mb-3.ms-3.pe-xxl-5 <strong>3. Optimización local:</strong> buscar el óptimo en cada paso.\n\n            td.bg-white.align-baseline.text-start.pb-0\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Problema de la mochila (Knapsack Problem).  \n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0  Problema de la moneda mínima (Coin Change Problem).\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0  Árboles de expansión mínima (Minimum Spanning Tree).\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0  Algoritmo de Huffman (Compresión de datos).\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Problema de selección de actividades.\n\n          tr\n            td.text-bold.align-baseline.text-start.border-right-gris Greedy\n            td.text-start.pt-0.bg-white.border-bottom-gris.border-right-gris\n              p.mb-0 Según Silva Ramírez (2018), \"los algoritmos voraces toman decisiones localmente óptimas en cada paso, esperando llegar a una solución globalmente óptima\" (p. 145).\n            td.bg-white.border-bottom-gris\n          \n          tr\n            td.bg-white.border-bottom-gris.border-right-gris\n            td.bg-white.text-start.border-bottom-gris(colspan=\"2\") En situaciones donde se requiera tomar decisiones paso a paso, los algoritmos voraces permiten hacer la mejor elección local en cada momento, buscando alcanzar una solución óptima global.\n\n          tr\n            td.bg-gris.border-right-gris.text-bold.align-baseline.text-start Vuelta atrás\n            td.bg-white.border-bottom-gris.border-right-gris.align-baseline.text-start\n              p.mb-3 Este paradigma es esencial para la búsqueda exhaustiva, donde se requiere:\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0.pe-xl-4 Explorar todas las posibilidades.\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0.pe-xl-4 Deshacer decisiones que no produzcan soluciones.\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0.pe-xl-4 Encontrar todas las soluciones posibles. \n            td.bg-white.border-bottom-gris.align-baseline.text-start\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Sudoku.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Problema de las N reinas.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Generación de subconjuntos.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Búsqueda de caminos en laberintos.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Resolución de problemas de partición.\n              div.d-flex.mb-1\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Solución de puzzles y juegos.\n\n          tr  \n            td.bg-gris.text-bold.align-baseline.text-start.border-right-gris.border-bottom-gris Backtracking\n            td.bg-gris.text-start.border-bottom-gris(colspan=\"2\") El <em>backtracking</em> es una herramienta que permite explorar muchas combinaciones posibles, “especialmente cuando no hay un criterio directo para saber, de inmediato, cuál es la mejor opción”.\n\n    #t_1_2.titulo-segundo\n      div.d-flex\n        span.me-3 1.2  \n        h2 Análisis y optimización de eficiencia\n    \n    .row.mb-4\n      .col-12.col-xl-4.d-none.d-xl-block(data-aos=\"fade-right\")\n        img(src='@/assets/curso/unidad/img-16.png', alt='Texto que describa la imagen')\n      .col-12.col-xl-8(data-aos=\"fade-left\")\n        .d-flex.align-items-start.bg-4.p-4.mb-4(data-aos=\"fade-left\")\n          img.me-3(style=\"width: 90px\" src='@/assets/curso/unidad/img-17.svg', alt='Texto que describa la imagen')\n          .d-flex.flex-column\n            p.pe-xl-3.mb-0(data-aos=\"fade-up\") La eficiencia es un aspecto crucial en el desarrollo de algoritmos. Como señala Castillo Romero (2019), \"la diferencia entre un algoritmo eficiente y uno ineficiente, puede significar la diferencia entre resolver un problema en segundos o en años\" (p. 178). Por su parte, Silva Ramírez (2018), \"el análisis de eficiencia no solo nos permite comparar algoritmos, sino que también nos ayuda a predecir su comportamiento ,en diferentes escenarios\" (p. 78).\n\n    p.mb-3 <strong>Tabla 2.</strong> Técnicas de optimización de eficiencia\n\n    .tabla-a.mb-4\n      table.text-center\n        tbody\n          tr\n            td.bg-morado.text-white.text-bold.border-bottom-white(rowspan=\"2\" width=\"25%\") Métricas de rendimiento\n            td.bg-gris.border-right-gris(width=\"30%\") Tiempo de ejecución\n            td.bg-gris\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Tiempo real (wall-clock time).\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Tiempo de CPU.\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Número de operaciones básicas.\n          tr\n            td.bg-white.border-right-gris Uso de memoria\n            td.bg-white\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Memoria estática. \n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Memoria dinámica.\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Pila de llamadas recursivas.\n          \n          tr\n            td.bg-morado.text-white.text-bold.border-bottom-white(width=\"25%\") Notación asintótica\n            td.bg-gris.border-right-gris Notación asintótica\n            td.bg-gris.text-start.pe-xl-5 La notación asintótica permite describir el comportamiento del algoritmo sin depender de detalles de implementación específicos.\n\n          tr\n            td.bg-morado.text-white.text-bold.border-bottom-white(rowspan=\"2\" width=\"25%\") Técnicas de optimización\n            td.bg-gris.border-right-gris(width=\"30%\") Optimización de código\n            td.bg-gris.text-start\n              p.mb-3 Mejorar partes del código para que sea más eficiente aplicando:\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Eliminación de código innecesario.\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Simplificar operaciones. \n          tr\n            td.bg-white.border-right-gris Optimización de bucles\n            td.bg-white\n              p.mb-3.text-start.pe-xl-5 Se enfoca en la optimización de bucles o ciclos, algunas de las técnicas son:\n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Reducir el número de iteraciones. \n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Terminar antes de tiempo el bucle. \n              div.d-flex.mb-1.ms-3\n                i.fas.fa-chevron-right.fs-18px.me-2.text-morado\n                p.fs-18px.mb-0 Mover operaciones fuera del bucle. \n\n    .row.mb-5\n      .col-12.col-xl-8.col-xxl-8.d-flex.flex-column\n        .d-flex.align-items-start.bg-amarillo.p-4.mb-4(data-aos=\"fade-right\")\n          img.me-3(style=\"width: 90px\" src='@/assets/curso/unidad/img-18.svg', alt='Texto que describa la imagen')\n          .d-flex.flex-column\n            p.pe-xl-3.mb-0(data-aos=\"fade-up\") Estas técnicas de optimización de algoritmos, son útiles al trabajar con grandes cantidades de datos o cuando se debe optimizar el programa para que responda más rápido.\n        p.mb-0 La finalidad del concepto de un algoritmo eficiente se centra en el diseño y análisis de soluciones que permitan resolver de manera ágil, y utilizar la menor cantidad de recurso posible, como tiempo de ejecución y memoria, es decir; la eficiencia se traduce en la capacidad del algoritmo de realizar su tarea, utilizando la menor cantidad de medios posibles.  \n      .d-none.d-xl-block.col-xl-4.col-xxl-4.mx-auto.mt-4.mt-xl-0(data-aos=\"fade-left\")\n        img(src='@/assets/curso/unidad/img-19.png', alt='Texto que describa la imagen')  \n\n    #t_1_3.titulo-segundo\n      div.d-flex\n        span.me-3 1.3  \n        h2 Importancia de los algoritmos eficientes\n\n    p.mb-4 A continuación, se resumen algunas de las principales importancias de los algoritmos eficientes:\n\n    ImagenInfografica.color-secundario.mb-5\n      template(v-slot:imagen)\n        figure\n          img(src='@/assets/curso/unidad/img-20.png', alt='Texto que describa la imagen')\n\n      .tarjeta.bg-white.p-4(x=\"14%\" y=\"62%\" numero=\"+\")\n        .h5.mb-2 Ahorro de tiempo\n        p Un algoritmo eficiente es aquel que se ejecuta en menos tiempo.\n      .tarjeta.bg-white.p-4(x=\"33%\" y=\"21%\" numero=\"+\")\n        .h5.mb-2 Optimización de recursos\n        p La eficiencia permite que se utilicen menos recursos como memoria, energía, CPU, importante en el desarrollo de algoritmos que se ejecuten en equipos con limitaciones físicas, como dispositivos móviles o sistemas embebidos.\n      .tarjeta.bg-white.p-4(x=\"67%\" y=\"21%\" numero=\"+\")\n        .h5.mb-2 Escalabilidad\n        p Los algoritmos eficientes permiten manejar el crecimiento en el volumen de datos, sin que su rendimiento se vea afectado; esto es importante en aplicaciones que operen grandes bases de datos o que requieran procesar grandes volúmenes de datos en poco tiempo.\n      .tarjeta.bg-white.p-4(x=\"86%\" y=\"62%\" numero=\"+\")\n        .h5.mb-2 Reducción de costos \n        p En entornos comerciales y empresariales, un algoritmo reduce el costo de operación, debido a que utiliza menos infraestructura para llevar a cabo su trabajo.\n\n    p.mb-4 En resumen, el concepto de algoritmos eficientes, se enfoca en la creación de soluciones que se ejecuten de manera óptima y económica posible. Lo anterior es vital para el desarrollo de software y sistemas de entornos donde los recursos son limitados o se deba priorizar el rendimiento. \n\n    .row.mb-5.mx-0\n      .d-none.d-xl-block.col-4.px-0(data-aos=\"fade-right\")\n        img.h-100(src='@/assets/curso/unidad/img-21.png', alt='Texto que describa la imagen')\n      .col-12.col-xl-8.d-flex.align-items-center.bg-4.p-4(data-aos=\"fade-left\")\n        p.mb-0(data-aos=\"fade-up\") Imagine dos algoritmos para ordenar una lista de números. Uno de ellos usa un método simple que compara cada número con los demás (como el <em>Bubble Sort</em>), mientras que el otro utiliza un método más optimizado (como el <em>Merge Sort</em>). Ambos logran ordenar la lista, pero <strong>Merge Sort</strong> lo hace en mucho menos tiempo para listas grandes, porque tiene una eficiencia mucho mayor, en términos de tiempo de ejecución.\n\n    p.mb-4 Para practicar y perfeccionar los conceptos adquiridos en este primer tema de la unidad, le invitamos a leer los siguientes libros: \n\n    .bg-full-width.border-top-9-azul\n      .px-4.px-md-5.pt-5.pb-0\n        h2 Material complementario\n        .row\n          .col-12.col-md-6.col-lg-8\n            p.d-flex.my-4\n              img.me-3.mb-auto.mt-1(src='@/assets/componentes/book.svg' :style=\"{'max-width':'16px'}\")\n              a.text-small.text-primary(target=\"_blank\", href=\"https://elibro.net/en/ereader/tecnologicadeloriente/68438?page=21\") Moreno, E. (2012). Grafos: fundamentos y algoritmos. Editorial ebooks Patagonia - J.C. Sáez Editor.\n            p.d-flex.my-4\n              img.me-3.mb-auto.mt-1(src='@/assets/componentes/book.svg' :style=\"{'max-width':'16px'}\")\n              a.text-small.text-primary(target=\"_blank\", href=\"https://elibro.net/es/ereader/tecnologicadeloriente/69931?page=1\") Mancilla Herrera, A. (2015). Diseño y construcción de algoritmos. Universidad del Norte.\n            p.d-flex.my-4\n              img.me-3.mb-auto.mt-1(src='@/assets/componentes/book.svg' :style=\"{'max-width':'16px'}\")\n              a.text-small.text-primary(target=\"_blank\", href=\"https://elibro.net/es/ereader/tecnologicadeloriente/106523?page=1\") Nolasco Valenzuela, J. S. (2018). Python: aplicaciones prácticas. RA-MA Editorial.\n            p.d-flex.my-4\n              img.me-3.mb-auto.mt-1(src='@/assets/componentes/youtube-icon.svg' :style=\"{'max-width':'16px'}\")\n              a.text-small.text-primary(target=\"_blank\", href=\"https://www.youtube.com/watch?v=tf4qLcKk6ZU\") LinuxChad. (2023). El origen de Python [Vídeo]\n          .col-12.col-md-6.col-lg-3\n            figure\n              img(src='@/assets/componentes/material-complementario.svg', alt='Imagen de material complementario')\n\n\n</template>\n\n<script>\nexport default {\n  name: 'Tema1',\n  data() {\n    return {\n      items: [\n        {\n          text: 'Siempre debe tener un inicio.',\n        },\n        {\n          text:\n            'Deberá ser preciso, contemplar el orden estructural y secuencial del proceso y establecer prioridades.',\n        },\n        {\n          text:\n            'Debe estar definido, lo que a su vez traduce en que cada vez que se ejecute el algoritmo, se obtienen los mismos resultados.',\n        },\n        {\n          text:\n            'Siempre debe tener un fin, deberá terminar el algún momento; es decir, un número de pasos establecido.',\n        },\n      ],\n    }\n  },\n  mounted() {\n    this.$nextTick(() => {\n      this.$aosRefresh()\n    })\n  },\n}\n</script>\n\n<style lang=\"sass\">\n.SplitContainer\n  background: rgb(85,122,250)\n  background: linear-gradient(0deg, rgba(232,238,253,1) 0%, rgba(232,238,253,1) 50%, rgba(255,255,255,1) 50%)\n\n  .yellowCard\n    padding: 2rem\n    background-color: #FBF6DB\n\n.PurpleContainer\n  background-color: rgb(232,238,253)\n\n.SplitContainer2\n  background: rgb(85,122,250)\n  background: linear-gradient(0deg, rgba(255,255,255,1) 0%, rgba(255,255,255,1) 50%, rgba(232,238,253,1) 50%)\n\n  .yellowCard\n    padding: 2rem\n    background-color: #FBF6DB\n</style>\n"]}]}